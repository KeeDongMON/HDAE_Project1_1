/**********************************************************************************************************************
 * \file Emergency_stop.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Emergency_stop.h"

//unsigned int G_TofValue = 0;
volatile uint32_t count_enc = 0;
uint64 t1, t2, present;
static inline void Enable_Enc_Interrupt (void)
{
    MODULE_SRC.SCU.SCUERU[0].B.SRE = 1; // Service Request Enable
}

static inline void Disable_Enc_Interrupt (void)
{
    MODULE_SRC.SCU.SCUERU[0].B.SRE = 0; // Service Request Disable
}



float velocity(void){
    count_enc = 0;
    Enable_Enc_Interrupt();
    present = count_enc;// 굳이 필요? count_enc 초기화 언제해야하지?
//    delay_ms(1000);

    t1 = getTimeUs(); // 지금 조금 도는데도 인터럽트가 20번 이상 일어나는 에러가 발생함.
    while (count_enc != 80);// 한바퀴 구멍 20개. 구멍 나갈 때 들어올 때, 2번, rising /falling 2번 총 4번의 신호가 한번의 구멍 지날 때 발생함.
    t2 = getTimeUs();//
    Disable_Enc_Interrupt();
    return ((21.0 *10000)/ (t2-t1)); // m/s  즉 21* 10^-2 / 10^-6 = 21 * 10^4
}

float Braking_Distance(float v){
    float dis  = 1.0 * (v * v) /(3 * Deceleration_rate());
    return 1000 * dis; // m단위이니 tof 단위로 하려면 곱하기 1000을 함.//
//
}
float Deceleration_rate(void){ // 함수보다 실험적으로 값을 구해서 상수화 및 공식화하기.
    return 1.5;//
}

void Emergency_stop(void){
    my_printf("work\n");
    if (Tof_GetValue() < 100+ Braking_Distance(velocity()))//
        {
           my_printf("tof distance: %d\n",Tof_GetValue());
           Motor_stopChA();
           Motor_stopChB();
           my_printf("stop");
           int front_duty = 30;
           int back_duty = 30;
           //긴급 제동 Debugging용
           //TODO : 상세 로직 역회전하기.
           //Motor_movChA_PWM(front_duty, 0);
           //Motor_movChB_PWM(back_duty, 0);
           //delay_ms(500);
       }
    else{
        Motor_movChA_PWM(50, 1);
        Motor_movChB_PWM(50, 1);
    }



    }


//IFX_INTERRUPT(TofIsrHandler, 0, ISR_PRIORITY_CAN_RX);
//void TofIsrHandler(void)
//{
//    my_printf("02349\n");
//    unsigned int rxID;
//    unsigned char rxData[8] = {0,};
//    int rxLen;
//    Can_RecvMsg(&rxID, rxData, &rxLen);
//    unsigned int tofValue = rxData[2] << 16 | rxData[1] << 8 | rxData[0];
//    unsigned char dis_status = rxData[3];
//    unsigned short signal_strength = rxData[5] << 8 | rxData[4];
//    G_TofValue = tofValue; // 전역변수로 활용
//    my_printf("123:%d\n",tofValue);
//    if (signal_strength != 0) {
//        if (tofValue <= 100+ Braking_Distance())
//        {
//            my_printf("stop!!\n");
//            Motor_stopChA();
//            Motor_stopChB();
//            int front_duty = 30;
//            int back_duty = 30;
//
//            //긴급 제동 Debugging용
//            //TODO : 상세 로직 역회전하기.
//            Motor_movChA_PWM(front_duty, 0);
//            Motor_movChB_PWM(back_duty, 0);
//            delay_ms(500);
//        }
//    } else {
////        my_printf("out of range!\n"); // for debugging
//    }
//}


    //unsigned int Tof_getValue(void)
    //{
    //    return G_TofValue;
    //}
